# 联机模块

采用帧同步和websocket与后端固定服务器进行通信

## 同步逻辑

无论单机/联机模式中,用户的操作(铲除和种植)不再直接反映在scene中,而是放置在发送消息队列.

开始游戏,在create后也不会立刻出怪,而是等待接收队列的消费者消费到'gameStart'再在EventBus中发送开始游戏,

以下是监听EventBus的'gameStart'的项目

- 开始出怪
- 允许种植卡片
- 允许移除器械
- 允许星之碎片
- 允许cardSlot计时.

从初始化游戏到出怪spawner开始之间,这个时间段很短,但是出怪时机非常影响状态,因此出怪时机需要通过'gameStart'同步.

- [ ] spawner启动逻辑从`game scene`的create主函数移动到监听器的handler函数
- [ ] card,监听gameStart,否则设置为不可用(`could_plant`state = false)和不能冷却(`could_cooldown` state = false)
- [ ] 未来的gardener每几秒增加能量的启动触发也会监听

单机和联机,区别是发送队列的消费者逻辑不同,单机的消费者会直接消费消息并发送到接收队列中,联机的发送队列消费者会发送到网络通信,接收队列会监听网络队列.



**在接收到所有用户ready信息后,由服务器发送gameStart,其中带seed以便各种随机化的需要,当然,单人游戏中,发送队列会模拟服务器做这些操作直接发到接收队列**

**发送队列,发送入口会在各个原先会影响**

**接收队列会直接影响`game scene`保持帧数据立即得到处理,之后game scene的原有逻辑通过EventBus发送事件到card等产生影响**



### 帧同步流程

服务器：
1.服务器上每个比赛对象，都有一个成员的freamid，保存了当前比赛下一帧要进入的id
2.服务器上定义一个数据结构，dic_match_frames,用来保存我们所有玩家的每帧的操作。(录像回放，断线重连，不同步的情况，有无作弊，udp丢包时序问题，我们要补发给客户端的帧保存起来)
3.dic_next_frame_opts 每帧服务器将采集来的客户端的操作都存放在这里；(<battleid,opt>)
4.服务器开启一个线程Thread_SendFrameData去等待所有玩家准备ok(收到第一帧操作)，收到第一帧之后游戏正式开始，之后每隔66ms(15FPS)触发一次sendFrameDate
5.触发一个帧操作，保存当前的帧操作到dic_match_frames
6.遍历每个玩家给每个玩家发送帧操作。
7.发送”服务器认为“这个玩家还没同步的帧，每个玩家对象用sync_frameid记录的客户端已经同步到了多少帧了
	从sync_frameid+1，发送到最新的帧。--》(解决udp丢包和时序问题，补发帧)
8.采用udp将数据包发送出去 可能会发送补发的帧
9.服务器进入下一帧self.frameid++
10.服务器清空上一帧操作next_frame_opt.allplayeroperation.clear()


客户端：
11.客户端通过网络收到帧同步的数据包以后，OnLogicUpdate
12.每个客户端，也都会有一个sync_frameID记录当前客户端真正已经同步到哪个帧了
13.如果收到的帧id<sync_frameID  ,直接丢弃这个帧。
	a:为什么会出现这个情况。 因为udp会有先发后到，后发先到。
	b:为什么我们没有收到99帧，就开始处理100帧，能同步吗？[如果99帧没有处理，服务器在发100帧的时候会补发99帧]
14.如果上一帧的操作不为空，我们处理下一帧之前，一定要先同步一下上一帧的结果。
	客户端A: |----|---66.3--|----|
	客户端B: |----|---66.1--|----|
	每个客户端收到数据包的时间不一样。所以在帧与帧之间会发生时间的差异导致位置不同步。
	所有都用66ms迭代出新的位置和结果。统一都以66ms来迭代。
	处理下一帧之前每帧都同步；==》同样的输入--》同样的输出
15.跳帧：快速同步过时的帧完直到最新的一帧.
16.控制客户端根据操作来更新逻辑推进。
17.SendOperation:采集自己的操作，上报给服务器，“你认为”的下一帧，next_frame_id=this.sync_framed+1,发送给服务器
	(这个是  this.InvokeRepeating("Send_BattleReady", 0.5f, 0.2f);)
服务器：
18.服务器收到数据。更新服务器的sync_framed;
	比如：服务器[发送99帧，sync_frameid=98 ]--》客户端处理99帧--》上报100帧操作--》服务器收到100帧的操作(说明前99帧已经处理完了更新sync_frameid=99)--》服务器发送100帧数据
19.如果收到玩家操作帧id不等于马上要触发的帧id，说明玩家过时的操作。
	比如：客户端发送99帧--》服务器的sync_frameid=100 > 99所以直接丢弃。
20.把这个操作插入到next_frame_opt。等待下一帧处理。GOTO: 逻辑5

如何克服时序丢包？
客户端丢包：因为可以(13)服务器会补发丢到或者没有到的帧。
服务端丢包：下一帧马上会处理。

## 后端同步服务器启动

后端服务器请见本目录下的server文件

```bash
# 当前在sever文件夹下
make
cd ./dist
vi .env # 修改配置,例如改address和port
./mvzserver
```

